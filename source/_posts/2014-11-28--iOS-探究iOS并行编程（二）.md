title: "[iOS]探究iOS并行编程（二）"
categories:
  - 技术
date: 2014-11-28 11:26:28
tags: [iOS]
photos:
- /uploads/header/heliu.jpg
---

##Dispatch Queues
创建并管理Dispatch Queue：
获取全局的并行队列：系统会提供4个全局的并行队列，可以通过`dispatch_get_global_queue`来获取，
```objc
dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
```
后面可以指定优先级的全局队列，`DISPATCH_QUEUE_PRIORITY_HIGH`, `DISPATCH_QUEUE_PRIORITY_LOW`和`DISPATCH_QUEUE_PRIORITY_BACKGROUND`。

创建串行的队列：
可以用串行的队列来替代锁来保护共享的资源或可更改数据结构。必须显式的创建和管理队列，
```objc
dispatch_queue_t queue;
queue = dispatch_queue_create("com.example.MyQueue", NULL);
```

运行时获取普通队列：
`dispatch_get_current_queue`获取当前队列，如果在block里面执行，会获取block所在的队列。
`dispatch_get_main_queue`获取程序的主进程。
`dispatch_get_global_queue`用来获取全局的并行队列。

保存Context信息：
所有dispatch的东西，都可以通过`dispatch_set_context`和`dispatch_get_context`来保存信息。

为队列提供清理函数：
用`dispatch_set_finalizer_f`设置清理函数，

###向队列添加任务
分同步和异步两种方式添加任务。
异步：`dispatch_async`和`dispatch_async_f`，同步：`dispatch_sync`和`dispatch_sync_f`

可以并行运行循环：
```objc
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   printf("%u\n",i);
});
```

###运用信号量防止死锁
